### 프로젝트
기본 설정 
db: h2 인메모리로 테스트 하기 좋아서


단위 테스트 


### 연관관계의 주인
member <-> order (연관관계의 주인)
이유 order가 외래기키를 가지고 있음.
1. 데이터 일관성 : 외래키가 가진쪽이 일관적으로 수정 가능
2. 매핑이 간결 : 두 엔티티 모두 주인이면 복잡성 높아짐
3. 외래 키 관리: 주인이 왜래키를 관리함으로서 어떤 엔티티가 책임을 지고 있는지 명확해짐. 주인만이
   삭제와 수정이 가능해 혼란을 줄임 


### 값 타입은 변경 불가능하게 설계
ex) Address (Embeddable)
@Setter를 제거, 생성자의 값을 모두 초기화하여 변경 불가능한 클래스
JPA 스펙상 Embeddable 타입은 기본생성자를 생성해야함.
public -> protected 로 설정하여 안전하게 만듬 


### Setter를 사용하지 말자
Setter가 열려있으면 변경 포인트가 너무 많아, 어디서 변경됬는지 확인이 어렵다.

### 모든 연관관계는 지연로딩으로 설정
지연로딩(LAZY)
n+1 설정
ManyToOne(EAGER)
OenTOMany(LAZY) 
-> 하지만, n+1 방지하기 위해 ManyToOne(LAZY) 처리


### 컬렉션은 필드에서 초기화 하자
- 필드에서 바로 초기화 하는것이 null 문제에서 안전
- 하이버네이트가 엔티티 영속화때, 한번 감싸서 임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트가 문제가 발생할 수 있음.
```
   Member_member = new Member();
```
컬렉션을 변경하지 말고, 그대로 사용! 하이버네이트가 원하는 메커니즘 대로 작동하지않을 수 있음


### 컬럼명 생성 
테이블명 = SpringPhysicalNamingStrategy
카멜케이스 -> 언더스코어로 변경하여 생성


### 연관관계 편의 메소드
양방향 연관관계 일때는, 컨트롤 하는쪽에서 서로 세팅해줌.
양쪽 세팅을 하나의 코드로 해결

